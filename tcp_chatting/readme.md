## 07-08. TCP CHATTING

<br>

### 개발 결과물

- TCP를 이용하여 채팅서버, 채팅 클라이언트를 개발하였다.

- 서버에서는 단순하게 채팅에 참여한(소켓에 연결된) 클라이언트들을 관리한다.

- 클라이언트에서 채팅을 입력하면, 소켓을 통해 채팅이 서버로 전송되고, 서버는 다시 이를 소켓에 연결된 모든 클라이언트에 채팅을 다시 보내게 된다.

<br/>

### 소스코드 소개

👀 코드 상의 주석으로 설명되어 있으므로 핵심이라 생각되는 것만 간략하게 소개

- client 들을 관리하는 리스트를 생성하여, 이를 이용하여 클라이언트를 관리하였다.

  ```js
  // 채팅에 접속한 클라이언트들을 관리할 리스트.
  const groupQueue = []; // 추후 관리하는 부분은 너무 많아 소스코드에서 확인.
  ```

- 이전까지는 `socket.end` 를 제대로 활용하여 FIN 패킷을 이용하여 정석대로 종료하는 것을 해보지 않았었다. 여기서는 이를 제대로 구현해보았다.

  ```js
  /* ----------- clinet --------------*/
  // 클라이언트에서 quit을 통해 FIN을 보내면, 클라이언트는 보내는 것을 중지하고 받기만 할 수 있게 된다.
  // 이떄 연결이 완전히 끊긴 것은 아니기 때문에 half-close 라고 이야기한다.
  if (input === "quit") {
    socket.end();
  }

  /* ----------- server --------------*/
  // socket.on("end", () => {}) 에서 FIN 패킷이 들어온 것을 listen하고 callback 함수를 수행한다.
  socket.on("end", () => {
    try {
      socket.end(); // 클라이언트에게 FIN 패킷을 보낸다.
    } catch {
      console.log("socket destroy error");
    }
  });

  /* ----------- clinet --------------*/
  // server 쪽에서  FIN 패킷을 보냈으므로 이를 확인하고 client에서 소켓연결을 종료할 것이다.
  // 이때 소켓 연결이 끊어진 것을 확인하는 이벤트 리스너 socket.on("close", () => {}) 가 수행될 것이다.
  socket.on("close", () => {
    console.log("> echo-client is de-activated");
    r.close();
    exit(1);
  });

  /* ----------- server --------------*/
  // 서버에서도 끊어졌음이 확인되고 이벤트 리스너 socket.on("close", () => {}) 가 수행될 것이다.
  socket.on("close", () => {
    console.log("> someone disconnect");
  });
  ```

<br/>

### 데모영상 소개

- 서버 프로그램 동작시키면, tcp 채팅 서버가 동작한다.
- 클라이언트 프로그램을 실행시키면 클라이언트가 tcp 채팅 서버에 연결되고, 그것에 대한 정보가 출력된다.
- 채팅을 보내면, 채팅이 서버로 전송되고, 서버에서 다시 채팅방 안에 있는 모든 클라이언트에게 채팅이 보내진다.

<br/>

### 느낀점

- 채팅이 어떻게 동작하는지 그 자세한 내용을 구현을 통해 배울수 있었다.
- 이전에 인턴을 하면서 소켓에 대한 내용을 잘 모르고, 채팅을 구현했었던 적이 있었는데, 이 과정을 통해 소켓 기반의 채팅에 대해 좀 더 잘 이해할 수 있는 기회가 되었던 것 같다.

<br/>

---

#### 🌛 구현한 코드의 내용에 대한 자세한 설명은 js 파일 안에 주석으로 첨부되어있습니다.

#### 🌜 따라서 핵심이라 생각되는 코드를 제외한 나머지 코드에 대한 자세한 내용은 해당 readme에서 제외하였습니다.
